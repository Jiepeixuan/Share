##Java
### 1.多线程
#### 1.1 进程状态
![多线程详细](/img/thread.png)<br/>

> **1.NEW(新建尚未运行/启动)**
>
> 还没调用start，或者调用了start()方法，不一定立即改变线程状态，中间可能需要一些步骤才完成一个线程的启动。
>
> **2.RUNNABLE(处于可运行状态：正在运行或准备运行)**
> 
> start调用结束，线程由NEW变成RUNNABLE，存活着，并尝试占用CPU资源，yield操作时，线程还是RUNNABLE状态，只是它有一个细节的内部变化，做一个简单的让步。在Java层面是RUNNABLE的状态，并不代表一定处于运行中的状态，比如BIO中，线程正阻塞在网络等待的时候，看到的状态依然是RUNNABLE状态，而底层线程已经被阻塞住了。
>
> **3.BLOCKED(等待获取锁时进入的状态)** 
> 线程被挂起了，原因通常是因为它在等待一个锁，当某个**synchronized**正好有线程在使用时，一个线程尝试进入这个临界区，就会被阻塞，直到另一个线程走完临界区或发生了相应锁对象的wait操作后，它才有机会去争夺进入临界区的权利。当抢到锁之后，才会从BLOCKED状态恢复到RUNNABLE状态。这个状态它好像什么也不做一样。
>
> **4.WAITING(通过wait方法进入的等待)** 
>
>当wait，join，park方法调用时，进入waiting状态。前提是这个线程已经拥有锁了。
>
>>BLOCKED和WAITING状态的区别是：
>
>>A、blocked是虚拟机认为程序还不能进入某个区域，因为同时进去就会有问题，这是一块临界区。
>>B、发生wait等操作的先决条件是要进入临界区，也就是线程已经拿到锁了，自己可能进去做了一些事情，但此时通过判定业务上的参数，发现还有一些其他配合的资源没有准备充分，那么自己就等等再做其他事情。

>在WAITING状态下，如果发生了interrupt操作，则处于该状态的线程在内部会抛出一个InterruptedException，这个异常应当在run方法内捕获，使得run方法正常地执行完成，当然捕获异常后，是决定让线程继续运行，还是结束等要根据业务场景才处理。如果发生了notify动作，则会从等待池当中唤醒一个线程重新恢复到Runnable状态，如果是notifyall操作，则唤醒所有等待线程。 
>
> **5.TIMED_WAITING(通过sleep或wait timeout方法进入的限期等待的状态)**
> 
> 通过wait(t),sleep(t),join(t),parkNanos,parkUntil等方法进入此状态。当时间达到时触发线程回到工作状态Runnable。interrupt只对处于waiting或timed_waiting状态的线程起作用，对其他状态不起作用。 
>
> **6.TERMINATED(线程终止状态)**
> 
> 线程结束了，就处于这种状态，也就是run方法运行完了。这只是Java语言级别的一种状态，在操作系统内部可能已经注销了相应的线程，或者将它复用给其他需要使用线程的请求。


#### 1.2 开启线程的三种方式
     1.新建类继承 Thread 类实现线程

     2.通过实现接口 Runnable 实现创建线程

     3.使用 Callable、ExecutionException、ExecutorService、Future 等类，Executors 框架实现线程，此方法：相对前两种可抛异常，且有返回值。

>    **说明**：前两种主要是通过继承线程类或实现接口，来实现 run() 方法，线程对象调用 start() 方法启动线程
#### 1.3 run()和start()方法区别
   
    start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。

    run() : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！
#### 1.4sleep/wait/notify
>    sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。
    
>    sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。
    
>    当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 

#### 1.5Java线程池

#### 1.6synchronized与Lock的区别、synchronized用法
>主要相同点：Lock能完成synchronized所实现的所有功能
    
>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而synchronized是在JVM层面上实现的，synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。Lock锁的范围有局限性，块范围，而synchronized可以锁住块、对象、类。

#### 1.7并发特性
>**1.原子性**
>
>     即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：

>请分析以下哪些操作是原子性操作：
>
>     x = 10;         //语句1
>
>     y = x;         //语句2
>
>     x++;           //语句3
>
>     x = x + 1;     //语句4
>     
>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。

>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。

>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。

>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

>所以上面4个语句只有语句1的操作具备原子性。

>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。

>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

>**2.可见性**
>
>     可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。于可见性，Java提供了volatile关键字来保证可见性。

>volatile保证可见性的原理是在每次 访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。
　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。



>**3.有序性**

>     即程序执行的顺序按照代码的先后顺序执行。

>指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，
它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终
执行结果和代码顺序执行的结果是一致的。

#### 1.8volatile的原理</br>
#### 1.9synchronize的原理</br>
#### 1.10lock原理</br>
#### 1.11volatile用法
#### 1.12进程与线程
#### 1.13死锁

>死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。很显然，如果没有外力的作用，那麽死锁涉及到的各个进程都将永远处于封锁状态。
    
>只要下面四个条件有一个不具备，系统就不会出现死锁。
>
>>**〈1〉互斥条件**
>> 
>> 即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。
> 
>> **〈2〉不可抢占条件**
>> 
>> 进程所获得的资源在未使用输入代完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。
    
>> **〈3〉占有且申请条件**
>> 
>> 进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。
> 
>>**〈4〉循环等待条件**
>>
>>存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。
  上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。

#### 1.14ReentrantLock
#### 1.15并发集合了解哪些
#### 1.16CAS介绍
#### 1.17如何保证多线程读写文件的安全
#### 1.18如何保证线程安全
### 2JVM
#### 2.1GC回收策略
#### 2.2Java中对象的生命周期
#### 2.3JVM 内存区域 开线程影响哪块内存（内存分配）
#### 2.4JVM内存模型
###类加载机制
####双亲委派模型
###集合类
####HashMap实现原理
####hashmap如何put数据（从hashmap源码角度讲解）？
####ConcurrentHashMap 的实现原理
####集合 Set实现 Hash 怎么防止碰撞
####TreeMap
####HashSet与HashMap怎么判断集合元素重复
###抽象类和接口的区别
###进程调度
###Java注解
###String buffer 与String builder 的区别
###Java四种引用
####强引用置为null，会不会被回收
###String 为什么要设计成不可变的
###Object类的equal 和hashcode 方法重写，为什么？</br>


##Android
###LruCache原理
###Glide原理
####glide 使用什么缓存
####Glide 内存缓存如何控制大小
###模块化的好处、原因
###统计启动时长、标准
###如何保障应用的稳定性
###ThreadLocal原理
###动态布局
###热修复、插件化
###性能优化
####保证应用不卡顿
####Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）
###SP是进程同步的吗?有什么方法做到同步
###介绍下SurfView
###BroadcastReceiver，LocalBroadcastReceiver 区别
###Bundle 机制
###Handler 机制
###Android事件分发机制
###App启动流程，从点击桌面开始


###Android 的大体架构图
###点击 Android Studio 的 build 按钮后发生了什么
![多线程详细](/img/apkbuild.png)

>**1.AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件**
>
>如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。
>**2.AIDL工具会将所有的aidl接口转化为java接口。**
>
>**3.所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。**
>
>**4.Dex工具会将上述产生的.class文件及第三库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。**
>
>**5.ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。**
>
>**6.通过Jarsigner工具，对上面的apk进行debug或release签名**
>
>生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。
>
>**7. 通过zipalign工具，将签名后的apk进行对齐处理。**
>
>调用buildtoolszipalign，对签名后的apk文件进行对齐处理，使apk中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问apk文件时会更快。同时也减少了在设备上运行时的内存消耗。这样我们的最终apk就生成完毕了。

###一个应用程序安装到手机上时发生了什么
###对 Dalvik、ART 虚拟机有基本的了解
###Android 上的 Inter-Process-Communication 跨进程通信时如何工作的
###App 是如何沙箱化，为什么要这么做；
###权限管理系统（底层的权限是如何进行 grant 的）
###动态权限适配方案，权限组的概念
###进程和 Application 的生命周期；
###系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程
###RecycleView的使用，原理,recycleview listview 的区别,性能
###listview图片加载错乱的原理和解决方案
###MVP模式
###RxJava
###网络请求缓存处理，okhttp如何处理网络缓存的
###handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）
###图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM
###进程保活
###广播（动态注册和静态注册区别，有序广播和标准广播）
###service生命周期
###多线程
####多线程（关于AsyncTask缺陷引发的思考）
####Android系统为什么会设计ContentProvider，进程共享和线程安全问题
####Android线程有没有上限，然后提到线程池的上限
###数据库数据迁移问题
###进程间通信的方式
###计算一个view的嵌套层级
###多线程断点续传原理
###activity栈
###断点续传的实现
###Android进程分类
###ANR的原因
###Activity与Fragment之间生命周期比较
####fragment 各种情况下的生命周期
####横竖屏切换的时候，Activity 各种情况下的生命周期
####Activity 上有 Dialog 的时候按 home 键时的生命周期
####前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法
###广播的使用场景
###Oom 是否可以try catch
###AlertDialog,popupWindow,Activity区别
###Application 和 Activity 的 context 对象的区别
###序列化的作用，以及 Android 两种序列化的区别，Android为什么引入Parcelable，简化Parcelable的使用
###ANR怎么分析解决
###AIDL机制</br>
###AsyncTask机制</br>
###如何取消AsyncTask</br>


##计算机网络
###Https
####如何验证证书的合法性
####哪里用了非对称加密
####Https请求慢的解决办法
* DNS，携带数据，直接访问IP


###TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） 

##算法
###排序，快速排序的实现、堆排序实现
###B树、B+树的介绍
###图：有向无环图的解释
###二叉树 深度遍历与广度遍历
###判断环（猜测应该是链表环）
###链表反转
###x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完
###二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径
###一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法
###string to integer</br>
###合并多个单有序链表（假设都是递增的）</br>
###两个不重复的数组集合中，求共同的元素


##设计模式
###适配器模式，装饰者模式，外观模式的异同
###生产者模式
###观察者模式

##加密技术
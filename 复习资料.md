##Java
### 多线程
#### 1. 进程状态
![多线程详细](/img/thread.png)<br/>

> **1.NEW(新建尚未运行/启动)**
>
> 还没调用start，或者调用了start()方法，不一定立即改变线程状态，中间可能需要一些步骤才完成一个线程的启动。
>
> **2.RUNNABLE(处于可运行状态：正在运行或准备运行)**
> 
> start调用结束，线程由NEW变成RUNNABLE，存活着，并尝试占用CPU资源，yield操作时，线程还是RUNNABLE状态，只是它有一个细节的内部变化，做一个简单的让步。在Java层面是RUNNABLE的状态，并不代表一定处于运行中的状态，比如BIO中，线程正阻塞在网络等待的时候，看到的状态依然是RUNNABLE状态，而底层线程已经被阻塞住了。
>
> **3.BLOCKED(等待获取锁时进入的状态)** 
> 线程被挂起了，原因通常是因为它在等待一个锁，当某个**synchronized**正好有线程在使用时，一个线程尝试进入这个临界区，就会被阻塞，直到另一个线程走完临界区或发生了相应锁对象的wait操作后，它才有机会去争夺进入临界区的权利。当抢到锁之后，才会从BLOCKED状态恢复到RUNNABLE状态。这个状态它好像什么也不做一样。
>
> **4.WAITING(通过wait方法进入的等待)** 
>
>当wait，join，park方法调用时，进入waiting状态。前提是这个线程已经拥有锁了。
>
>>BLOCKED和WAITING状态的区别是：
>
>>A、blocked是虚拟机认为程序还不能进入某个区域，因为同时进去就会有问题，这是一块临界区。
>>B、发生wait等操作的先决条件是要进入临界区，也就是线程已经拿到锁了，自己可能进去做了一些事情，但此时通过判定业务上的参数，发现还有一些其他配合的资源没有准备充分，那么自己就等等再做其他事情。

>在WAITING状态下，如果发生了interrupt操作，则处于该状态的线程在内部会抛出一个InterruptedException，这个异常应当在run方法内捕获，使得run方法正常地执行完成，当然捕获异常后，是决定让线程继续运行，还是结束等要根据业务场景才处理。如果发生了notify动作，则会从等待池当中唤醒一个线程重新恢复到Runnable状态，如果是notifyall操作，则唤醒所有等待线程。 
>
> **5.TIMED_WAITING(通过sleep或wait timeout方法进入的限期等待的状态)**
> 
> 通过wait(t),sleep(t),join(t),parkNanos,parkUntil等方法进入此状态。当时间达到时触发线程回到工作状态Runnable。interrupt只对处于waiting或timed_waiting状态的线程起作用，对其他状态不起作用。 
>
> **6.TERMINATED(线程终止状态)**
> 
> 线程结束了，就处于这种状态，也就是run方法运行完了。这只是Java语言级别的一种状态，在操作系统内部可能已经注销了相应的线程，或者将它复用给其他需要使用线程的请求。


#### 2. 开启线程的三种方式
     1.新建类继承 Thread 类实现线程

     2.通过实现接口 Runnable 实现创建线程

     3.使用 Callable、ExecutionException、ExecutorService、Future 等类，Executors 框架实现线程，此方法：相对前两种可抛异常，且有返回值。

>    **说明**：前两种主要是通过继承线程类或实现接口，来实现 run() 方法，线程对象调用 start() 方法启动线程
#### 3. run()和start()方法区别
   
    start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。

    run() : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！
####sleep/wait/notify
>    sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。
    
>    sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。
    
>    当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备 

####Java线程池
####线程间 操作 List
####synchronized与Lock的区别、synchronized用法
>主要相同点：Lock能完成synchronized所实现的所有功能
    
>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而synchronized是在JVM层面上实现的，synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。Lock锁的范围有局限性，块范围，而synchronized可以锁住块、对象、类。

####volatile的原理</br>
####synchronize的原理</br>
####lock原理</br>
####volatile用法
####进程与线程
####死锁

>死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。很显然，如果没有外力的作用，那麽死锁涉及到的各个进程都将永远处于封锁状态。
    
>只要下面四个条件有一个不具备，系统就不会出现死锁。
>
>>**〈1〉互斥条件**
>> 
>> 即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。
> 
>> **〈2〉不可抢占条件**
>> 
>> 进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。
    
>> **〈3〉占有且申请条件**
>> 
>> 进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。
> 
>>**〈4〉循环等待条件**
>>
>>存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。
  上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。

####ReentrantLock
####并发集合了解哪些
####CAS介绍
####如何保证多线程读写文件的安全
####如何保证线程安全
###JVM
####GC回收策略
####Java中对象的生命周期
####JVM 内存区域 开线程影响哪块内存（内存分配）
####JVM内存模型
###类加载机制
####双亲委派模型
###集合类
####HashMap实现原理
####hashmap如何put数据（从hashmap源码角度讲解）？
####ConcurrentHashMap 的实现原理
####集合 Set实现 Hash 怎么防止碰撞
####TreeMap
####HashSet与HashMap怎么判断集合元素重复
###抽象类和接口的区别
###进程调度
###Java注解
###String buffer 与String builder 的区别
###Java四种引用
####强引用置为null，会不会被回收
###String 为什么要设计成不可变的
###Object类的equal 和hashcode 方法重写，为什么？</br>


##Android
###LruCache原理
###Glide原理
####glide 使用什么缓存
####Glide 内存缓存如何控制大小
###模块化的好处、原因
###统计启动时长、标准
###如何保障应用的稳定性
###ThreadLocal原理
###动态布局
###热修复、插件化
###性能优化
####保证应用不卡顿
####Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）
###SP是进程同步的吗?有什么方法做到同步
###介绍下SurfView
###BroadcastReceiver，LocalBroadcastReceiver 区别
###Bundle 机制
###Handler 机制
###Android事件分发机制
###App启动流程，从点击桌面开始
###Android 的大体架构图
###点击 Android Studio 的 build 按钮后发生了什么
###一个应用程序安装到手机上时发生了什么
###对 Dalvik、ART 虚拟机有基本的了解
###Android 上的 Inter-Process-Communication 跨进程通信时如何工作的
###App 是如何沙箱化，为什么要这么做；
###权限管理系统（底层的权限是如何进行 grant 的）
###动态权限适配方案，权限组的概念
###进程和 Application 的生命周期；
###系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程
###RecycleView的使用，原理,recycleview listview 的区别,性能
###listview图片加载错乱的原理和解决方案
###MVP模式
###RxJava
###网络请求缓存处理，okhttp如何处理网络缓存的
###handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）
###图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM
###进程保活
###广播（动态注册和静态注册区别，有序广播和标准广播）
###service生命周期
###多线程
####多线程（关于AsyncTask缺陷引发的思考）
####Android系统为什么会设计ContentProvider，进程共享和线程安全问题
####Android线程有没有上限，然后提到线程池的上限
###数据库数据迁移问题
###进程间通信的方式
###计算一个view的嵌套层级
###多线程断点续传原理
###activity栈
###断点续传的实现
###Android进程分类
###ANR的原因
###Activity与Fragment之间生命周期比较
####fragment 各种情况下的生命周期
####横竖屏切换的时候，Activity 各种情况下的生命周期
####Activity 上有 Dialog 的时候按 home 键时的生命周期
####前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法
###广播的使用场景
###Oom 是否可以try catch
###AlertDialog,popupWindow,Activity区别
###Application 和 Activity 的 context 对象的区别
###序列化的作用，以及 Android 两种序列化的区别，Android为什么引入Parcelable，简化Parcelable的使用
###ANR怎么分析解决
###AIDL机制</br>
###AsyncTask机制</br>
###如何取消AsyncTask</br>


##计算机网络
###Https
####如何验证证书的合法性
####哪里用了非对称加密
####Https请求慢的解决办法
* DNS，携带数据，直接访问IP


###TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） 

##算法
###排序，快速排序的实现、堆排序实现
###B树、B+树的介绍
###图：有向无环图的解释
###二叉树 深度遍历与广度遍历
###判断环（猜测应该是链表环）
###链表反转
###x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完
###二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径
###一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法
###string to integer</br>
###合并多个单有序链表（假设都是递增的）</br>
###两个不重复的数组集合中，求共同的元素


##设计模式
###适配器模式，装饰者模式，外观模式的异同
###生产者模式
###观察者模式

##加密技术